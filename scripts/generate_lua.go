//go:build ignore

package main

import (
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

// Template for each Lua command Go file
const luaCommandFileTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"context"
	"fmt"
	"github.com/redis/go-redis/v9"
)

// {{ .FuncName }} executes the Lua script {{ .Name }} on Redis with {{ .Keys }} keys.
func {{ .FuncName }}(client redis.Cmdable, keys []string, args ...interface{}) (interface{}, error) {
	if len(keys) != {{ .Keys }} {
		return nil, fmt.Errorf("expected {{ .Keys }} keys but got %d", len(keys))
	}
	luaScript := ` + "`{{ .Content }}`" + `
	result, err := client.Eval(context.Background(), luaScript, keys, args...).Result()
	if err != nil {
		return nil, err
	}
	return result, nil
}
`

// Template for the centralized LuaScripts mapping
const luaScriptsMappingTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"github.com/redis/go-redis/v9"
)

// LuaScripts maps Lua script names to their corresponding Go functions.
var LuaScripts = map[string]func(redis.Cmdable, []string, ...interface{}) (interface{}, error){
{{- range . }}
    "{{ .Name }}": {{ .FuncName }},
{{- end }}
}
`

const includeRegex = `(?m)^[-]{2,3}[ \t]*@include[ \t]+(["'])(.+?)[; \t\n]*$`
const emptyLineRegex = `/^\s*$/gm`
const scriptDir = "./internal/lua"
const outputDir = "./internal/lua"

var rootPath = ""

type LuaCommand struct {
	Name     string
	FuncName string
	Content  string
	Keys     int
}

type Command struct {
	Name    string
	Options struct {
		NumberOfKeys int
		Lua          string
	}
}

type ScriptMetadata struct {
	Name         string
	NumberOfKeys int
	Path         string
	Content      string
	Token        string
	Includes     []ScriptMetadata
}

type Cache map[string]ScriptMetadata

func main() {
	// Get root path, look for a go.mod file
	rootPath = findRootPath()

	scripts := loadScripts(scriptDir)

	for _, script := range scripts {

		lc := LuaCommand{
			// remove -<number> from the name
			Name:     strings.Split(script.Name, "-")[0],
			FuncName: strings.Title(strings.Split(script.Name, "-")[0]),
			Content:  script.Options.Lua,
			Keys:     script.Options.NumberOfKeys,
		}

		// Delete the old file if it exists
		os.Remove(filepath.Join(outputDir, lc.Name+"_lua.go"))

		// Generate an individual Go file for each Lua script
		outFile, err := os.Create(filepath.Join(outputDir, lc.Name+"_lua.go"))
		if err != nil {
			log.Fatalf("failed to create output file: %v", err)
		}

		// Execute the template for the Lua script Go file
		tmpl := template.Must(template.New("luaCommand").Parse(luaCommandFileTemplate))
		err = tmpl.Execute(outFile, lc)
		if err != nil {
			log.Fatalf("failed to execute template: %v", err)
		}

		outFile.Close()
	}

	fmt.Println("Lua scripts Go files generated successfully")
}

func findRootPath() string {
	rootPath, err := exec.Command("git", "rev-parse", "--show-toplevel").Output()
	if err != nil {
		log.Fatalf("failed to find root path: %v", err)
	}
	return strings.TrimSpace(string(rootPath))
}

func loadScripts(dir string) []Command {
	luaFiles, err := filepath.Glob(filepath.Join(dir, "*.lua"))
	if err != nil {
		log.Fatalf("failed to list Lua files: %v", err)
	}

	if len(luaFiles) == 0 {
		log.Fatalf("No .lua files found!", dir)
	}

	commands := []Command{}
	// TODO: Use pointers for cache, so it's the same cache used in all commands
	cache := Cache{}

	for _, f := range luaFiles {
		var command Command

		command, cache = loadCommand(f, cache)
		commands = append(commands, command)
	}

	return commands
}

func loadCommand(file string, cache Cache) (Command, Cache) {
	filename := filepath.Base(file)
	filename = filepath.Join(rootPath, file)

	name, _ := splitFilename(filename)
	script := cache[name]
	if script.Name == "" {
		content, err := os.ReadFile(file)
		if err != nil {
			log.Fatalf("failed to read file: %v", err)
		}
		contentStr := string(content)
		script, cache = parseScript(filename, contentStr, cache)
	}

	c, _ := interpolate(script, []string{})
	lua := removeEmptyLines(c)
	name, numberOfKeys := script.Name, script.NumberOfKeys

	return Command{
		Name: name,
		Options: struct {
			NumberOfKeys int
			Lua          string
		}{
			NumberOfKeys: numberOfKeys,
			Lua:          lua,
		},
	}, cache
}

func parseScript(filename, content string, cache Cache) (ScriptMetadata, Cache) {
	name, numberOfKeys := splitFilename(filename)
	meta := cache[name]
	if meta.Name != "" && meta.Content == content {
		return meta, cache
	}

	fileInfo := ScriptMetadata{
		Path:         filename,
		Token:        getPathHash(filename),
		Content:      content,
		Name:         name,
		NumberOfKeys: numberOfKeys,
		Includes:     []ScriptMetadata{},
	}

	fileInfo, cache = resolveDependencies(fileInfo, cache, false, []string{})

	return fileInfo, cache
}

func interpolate(fileInfo ScriptMetadata, processed []string) (string, []string) {
	content := fileInfo.Content
	for _, include := range fileInfo.Includes {
		emitted := contains(processed, include.Path)
		fragment, processed := interpolate(include, processed)
		replacement := ""
		if !emitted {
			replacement = fragment
		}

		if replacement == "" {
			content = replaceAll(content, include.Token, "")
		} else {
			content = strings.Replace(content, include.Token, replacement, -1)
			content = replaceAll(content, include.Token, "")
		}

		processed = append(processed, include.Path)
	}
	return content, processed
}

func resolveDependencies(fileInfo ScriptMetadata, cache Cache, isInclude bool, stack []string) (ScriptMetadata, Cache) {
	for _, s := range stack {
		if s == fileInfo.Path {
			log.Fatalf("circular reference: %s", fileInfo.Path)
		}
	}
	stack = append(stack, fileInfo.Path)
	content := fileInfo.Content

	// while loop
	for {
		match := regexp.MustCompile(includeRegex).FindString(content)

		if match == "" {
			break
		}

		reference := strings.Split(match, "\"")[1]

		// Build path to included file
		var includedPath string
		// includedPath := filepath.Join(filepath.Dir(fileInfo.Path), ensureExt(reference, "lua"))

		if isPossiblyMappedPath(reference) {
			includedPath = resolvePath(ensureExt(reference, "lua"), stack)
		} else {
			includedPath = filepath.Join(filepath.Dir(fileInfo.Path), ensureExt(reference, "lua"))
		}

		includePaths := []string{}

		// if (hasFilenamePattern(includeFilename)) {
		// 	const filesMatched = await getFilenamesByPattern(includeFilename);
		// 	includePaths = filesMatched.map((x: string) => path.resolve(x));
		//   } else {
		// 	includePaths = [includeFilename];
		//   }
		includePaths = append(includePaths, includedPath)

		if len(includePaths) == 0 {
			raiseError(fileInfo, "file not found", match)
		}

		tokens := []string{}

		for _, includePath := range includePaths {
			for _, inc := range fileInfo.Includes {
				if inc.Path == includePath {
					raiseError(fileInfo, fmt.Sprintf("file already included: %s", includePath), match)
				}
			}

			includeMetadata := cache[includePath]
			var token string

			if includeMetadata.Name == "" {
				name, numberOfKeys := splitFilename(includePath)
				childContent := ""
				buf, err := os.ReadFile(includePath)
				if err != nil {
					if os.IsNotExist(err) {
						raiseError(fileInfo, fmt.Sprintf("include not found: %s", reference), match)
					} else {
						log.Fatalf("failed to read file: %v", err)
					}
				}

				childContent = string(buf)

				token = getPathHash(includePath)

				includeMetadata = ScriptMetadata{
					Name:         name,
					NumberOfKeys: numberOfKeys,
					Path:         includePath,
					Content:      childContent,
					Token:        token,
					Includes:     []ScriptMetadata{},
				}
				cache[includePath] = includeMetadata
			} else {
				token = includeMetadata.Token
			}

			tokens = append(tokens, token)
			includeMetadata, cache = resolveDependencies(includeMetadata, cache, true, stack)
			fileInfo.Includes = append(fileInfo.Includes, includeMetadata)
		}

		if len(tokens) > 0 {
			content = strings.Replace(content, match, tokens[len(tokens)-1], 1)
		}
	}

	fileInfo.Content = content

	// Do a last check to ensure that the file doesn't have any includes left
	for {
		match := regexp.MustCompile(includeRegex).FindString(fileInfo.Content)
		if match == "" {
			break
		}
	}

	if isInclude {
		cache[fileInfo.Path] = fileInfo
	} else {
		cache[fileInfo.Name] = fileInfo
	}

	return fileInfo, cache
}

func contains(arr []string, str string) bool {
	for _, a := range arr {
		if a == str {
			return true
		}
	}
	return false
}

func resolvePath(scriptName string, stack []string) string {
	// first := scriptName[0]
	var sn string

	// if (first === '~') {
	// 	scriptName = path.join(this.rootPath, scriptName.substr(2));
	//   } else if (first === '<') {
	// 	const p = scriptName.indexOf('>');
	// 	if (p > 0) {
	// 	  const name = scriptName.substring(1, p);
	// 	  const mappedPath = this.pathMapper.get(name);
	// 	  if (!mappedPath) {
	// 		throw new ScriptLoaderError(
	// 		  `No path mapping found for "${name}"`,
	// 		  scriptName,
	// 		  stack,
	// 		);
	// 	  }
	// 	  scriptName = path.join(mappedPath, scriptName.substring(p + 1));
	// 	}
	//   }

	//   return path.normalize(scriptName);

	// TODO: Support pathMapper
	// if first == '~' {
	// 	sn = filepath.Join(rootPath, scriptName[2:])
	// } else if first == '<' {
	// 	sn = scriptName[1:]
	// }
	sn = filepath.Join(rootPath, scriptName[2:])

	return filepath.Clean(sn)
}

func isPossiblyMappedPath(path string) bool {
	return path != "" && (path[0] == '~' || path[0] == '<')
}

func findPos(content string, match string) (line, column int) {
	pos := strings.Index(content, match)
	if pos == -1 {
		// Match not found, return -1 values to indicate failure
		return -1, -1
	}
	arr := strings.Split(content[:pos], "\n")
	line = len(arr)
	column = len(arr[len(arr)-1]) + strings.Index(match, "@include") + 1
	return
}

func raiseError(file ScriptMetadata, msg string, match string) {
	line, column := findPos(match, match)
	log.Fatalf("%s:%d:%d: %s", file.Path, line, column, msg)
}

func ensureExt(filename, ext string) string {
	foundExt := filepath.Ext(filename)
	if foundExt != "" && foundExt != "." {
		return filename
	}
	if ext != "" && ext[0] != '.' {
		ext = "." + ext
	}
	return filename + ext
}

func splitFilename(filePath string) (string, int) {
	filename := filepath.Base(filePath)
	name := strings.TrimSuffix(filename, filepath.Ext(filename))
	if !strings.Contains(name, "-") {
		return name, 0
	}
	numOfKeys := strings.Split(name, "-")[1]
	numOfKeysInt, err := strconv.Atoi(numOfKeys)
	if err != nil {
		return name, 0
	}

	return name, numOfKeysInt
}

func sha1Hash(content string) string {
	h := sha1.New()
	h.Write([]byte(content))
	sha1_hash := hex.EncodeToString(h.Sum(nil))
	return sha1_hash
}

func getPathHash(normalizedPath string) string {
	return fmt.Sprintf("@@%s", sha1Hash(normalizedPath))
}

func replaceAll(str string, find string, replace string) string {
	return strings.ReplaceAll(str, find, replace)
}

func removeEmptyLines(str string) string {
	emptyLineRegex := `(?m)^\s*$[\r\n]*`
	return regexp.MustCompile(emptyLineRegex).ReplaceAllString(str, "")
}
